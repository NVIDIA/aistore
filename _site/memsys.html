<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>MEMSYS | AIStore - distributed object storage</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="MEMSYS" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="AIStore is a lightweight object storage system with the capability to linearly scale-out with each added storage node and a special focus on petascale deep learning. See more at: github.com/NVIDIA/aistore" />
<meta property="og:description" content="AIStore is a lightweight object storage system with the capability to linearly scale-out with each added storage node and a special focus on petascale deep learning. See more at: github.com/NVIDIA/aistore" />
<link rel="canonical" href="http://localhost:4000/aistore/memsys" />
<meta property="og:url" content="http://localhost:4000/aistore/memsys" />
<meta property="og:site_name" content="AIStore - distributed object storage" />
<script type="application/ld+json">
{"headline":"MEMSYS","@type":"WebPage","url":"http://localhost:4000/aistore/memsys","description":"AIStore is a lightweight object storage system with the capability to linearly scale-out with each added storage node and a special focus on petascale deep learning. See more at: github.com/NVIDIA/aistore","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/aistore/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/aistore/feed.xml" title="AIStore - distributed object storage" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/aistore/">AIStore - distributed object storage</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">MEMSYS</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="" itemprop="datePublished">
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="memory-manager-and-slabsgl-allocator-mmsa">Memory Manager and Slab/SGL Allocator (MMSA)</h1>

<h2 id="overview">Overview</h2>

<p>MMSA is, simultaneously, a) Slab and SGL allocator, and b) memory manager
that is responsible to optimize memory usage between different (more vs less) utilized
Slabs.</p>

<p>Multiple MMSA instances may coexist in the system, each having its own
constraints and managing its own Slabs and SGLs.</p>

<p>MMSA includes a “house-keeping” part to monitor system resources, 
adjust Slab sizes based on their respective usages, and incrementally
deallocate idle Slabs. To that end, MMSA utilizes <code class="highlighter-rouge">housekeep</code> (project and runner).</p>

<h2 id="construction">Construction</h2>

<p>A typical initialization sequence includes steps, e.g.:
1) construct:</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">mm</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">memsys</span><span class="o">.</span><span class="n">MMSA</span><span class="p">{</span><span class="n">Name</span><span class="o">:</span> <span class="o">...</span><span class="p">,</span> <span class="n">TimeIval</span><span class="o">:</span> <span class="o">...</span><span class="p">,</span> <span class="n">MinPctFree</span><span class="o">:</span> <span class="o">...</span><span class="p">,</span> <span class="n">Name</span><span class="o">:</span> <span class="o">...</span><span class="p">,</span> <span class="n">Debug</span><span class="o">:</span> <span class="o">...</span><span class="p">}</span>
</code></pre></div></div>

<p><strong>Note</strong> that with the only exception of <code class="highlighter-rouge">Name</code> all the rest member variables (above) have their system defaults and can be omitted.</p>

<p>2) initialize:</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">err</span> <span class="o">:=</span> <span class="n">mm</span><span class="o">.</span><span class="n">Init</span><span class="p">(</span><span class="no">false</span> <span class="c">/* don't panic on error */</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
		<span class="o">...</span>
	<span class="p">}</span>
</code></pre></div></div>
<p>The example above shows initialization that ignores errors - in particular, insifficient minimum required memory (see the previous section).</p>

<p>Alternatively, MMSA can be initialized <em>not</em> to panic on errors:</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	 <span class="n">mm</span><span class="o">.</span><span class="n">Init</span><span class="p">(</span><span class="no">true</span> <span class="c">/* panic on error */</span><span class="p">)</span>
</code></pre></div></div>

<p>In addition, there are several environment variables that can be used
(to circumvent the need to change the code, for instance):</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	AIS_MINMEM_FREE
	AIS_MINMEM_PCT_TOTAL
	AIS_MINMEM_PCT_FREE
	AIS_DEBUG
</code></pre></div></div>

<h2 id="minimum-available-memory">Minimum Available Memory</h2>

<p>MMSA will try to make sure that there’s a certain specified amount of memory that remains available at all times.
Following are the rules to set this minimum:</p>

<ul>
  <li>1) environment <code class="highlighter-rouge">AIS_MINMEM_FREE</code> takes precedence over everything else listed below;</li>
  <li>2) if <code class="highlighter-rouge">AIS_MINMEM_FREE</code> is not defined, variables <code class="highlighter-rouge">AIS_MINMEM_PCT_TOTAL</code> and/or
   <code class="highlighter-rouge">AIS_MINMEM_PCT_FREE</code> define percentages to compute the minimum based on the total
   or the currently available memory, respectively;</li>
  <li>3) with no environment, the minimum is computed based on the following MMSA member variables:
    <ul>
      <li>MinFree     - memory that must be available at all times</li>
      <li>MinPctTotal - same, via percentage of total</li>
      <li>MinPctFree  - ditto, as % of free at init time</li>
      <li>example: memsys.MMSA{MinPctTotal: 4, MinFree: cmn.GiB * 2}</li>
    </ul>
  </li>
  <li>4) finally, if none of the above is specified, the constant <code class="highlighter-rouge">minMemFree</code> in the source</li>
</ul>

<h2 id="termination">Termination</h2>

<p>If the memory manager is no longer needed, terminating the MMSA instance is recommended.
This will free up all the slabs allocated to the memory manager instance.
Halt a running or initialized MMSA instance is done by:</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">mm</span><span class="o">.</span><span class="n">Terminate</span><span class="p">()</span>
</code></pre></div></div>

<h2 id="operation">Operation</h2>

<p>Once constructed and initialized, memory-manager-and-slab-allocator (MMSA) can be exercised via its public API that includes
<code class="highlighter-rouge">GetSlab</code> and <code class="highlighter-rouge">Alloc</code>. Notice the difference between the two:</p>
<ul>
  <li><code class="highlighter-rouge">GetSlab(128KB)</code> returns Slab that contains 128KB reusable buffers</li>
  <li><code class="highlighter-rouge">Alloc()</code> returns both a Slab and (an already allocated buffer) from this Slab.</li>
</ul>

<p>Note as well that <code class="highlighter-rouge">Alloc()</code> accepts an optional buffer-size parameter.</p>

<p>Once selected, each Slab can be used via its own public API that
includes <code class="highlighter-rouge">Alloc</code> and <code class="highlighter-rouge">Free</code> methods. In addition, each allocated SGL internally
utilizes one of the existing enumerated slabs to “grow” (that is, allocate more
buffers from the slab) on demand. For details, look for “grow” in the iosgl.go.</p>

<p>When running, the memory manager periodically evaluates
the remaining free memory resource and adjusts its slabs accordingly.
The entire logic is consolidated in one <code class="highlighter-rouge">work()</code> method that can, for instance,
“cleanup” (see <code class="highlighter-rouge">cleanup()</code>) an existing “idle” slab,
or forcefully “reduce” (see <code class="highlighter-rouge">reduce()</code>) one if and when the amount of free
memory falls below watermark.</p>

<h2 id="testing">Testing</h2>

<ul>
  <li>To run all tests while redirecting errors to standard error:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go test -v -logtostderr=true
</code></pre></div>    </div>
  </li>
  <li>To run one of the named tests for 100 seconds:</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go test -v -logtostderr=true -run=Test_Sleep -duration=100s
</code></pre></div></div>

<ul>
  <li>All tests for 2 minutes with verbose tracing and debug (i.e., assertions) enabled:</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AIS_DEBUG=memsys=1 go test -v -logtostderr=true -duration=2m
</code></pre></div></div>

<h2 id="global-memory-manager">Global Memory Manager</h2>

<p>In the interest of reusing a single memory manager instance across multiple packages outside the ais core package, the memsys package declares a <code class="highlighter-rouge">gMem2</code> variable that can be accessed through the matching exported Getter.
The notable runtime parameters that are used for the global memory manager are MinFreePct and TimeIval which are set to 50% and 2 minutes, respectively.
Note that more specialized use cases which warrant custom memory managers with finely tuned parameters are free to create their own separate <code class="highlighter-rouge">MMSA</code> instances.</p>

<p>Usage:</p>

<p>To access the global memory manager, a single call to <code class="highlighter-rouge">memsys.Init()</code> is all that is required. Separate <code class="highlighter-rouge">Init()</code> nor <code class="highlighter-rouge">Run()</code> calls should not be made on the returned MMSA instance.</p>

  </div><a class="u-url" href="/aistore/memsys" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/aistore/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">AIStore - distributed object storage</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">AIStore - distributed object storage</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>AIStore is a lightweight object storage system with the capability to linearly scale-out with each added storage node and a special focus on petascale deep learning. See more at: github.com/NVIDIA/aistore
</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
