<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>TRANSPORT | AIStore - distributed object storage</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="TRANSPORT" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="AIStore is a lightweight object storage system with the capability to linearly scale-out with each added storage node and a special focus on petascale deep learning. See more at: github.com/NVIDIA/aistore" />
<meta property="og:description" content="AIStore is a lightweight object storage system with the capability to linearly scale-out with each added storage node and a special focus on petascale deep learning. See more at: github.com/NVIDIA/aistore" />
<link rel="canonical" href="http://localhost:4000/aistore/transport" />
<meta property="og:url" content="http://localhost:4000/aistore/transport" />
<meta property="og:site_name" content="AIStore - distributed object storage" />
<script type="application/ld+json">
{"headline":"TRANSPORT","@type":"WebPage","url":"http://localhost:4000/aistore/transport","description":"AIStore is a lightweight object storage system with the capability to linearly scale-out with each added storage node and a special focus on petascale deep learning. See more at: github.com/NVIDIA/aistore","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/aistore/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/aistore/feed.xml" title="AIStore - distributed object storage" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/aistore/">AIStore - distributed object storage</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">TRANSPORT</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="" itemprop="datePublished">
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><strong>Package <code class="highlighter-rouge">transport</code> provides streaming object-based transport over HTTP for massive intra-AIS data transfers. AIStore utilizes this package for cluster-wide (aka “global”) rebalancing, distributed merge-sort, and more.</strong></p>

<ul>
  <li><a href="#build">Build</a></li>
  <li><a href="#description">Description</a></li>
  <li><a href="#closing-and-completions">Closing and completions</a></li>
  <li><a href="#commented-example">Commented example</a></li>
  <li><a href="#registering-http-endpoint">Registering HTTP endpoint</a></li>
  <li><a href="#on-the-wire">On the wire</a></li>
  <li><a href="#transport-statistics">Transport statistics</a></li>
  <li><a href="#stream-bundle">Stream Bundle</a></li>
  <li><a href="#testing">Testing</a></li>
  <li><a href="#environment">Environment</a></li>
</ul>

<h2 id="build">Build</h2>

<p>The package includes build-time support for two alternative http clients:</p>

<ul>
  <li>standard net/http</li>
  <li>3rd party github.com/valyala/fasthttp aka “fasthttp”</li>
</ul>

<p>The following is a quick summary:</p>

<table>
  <thead>
    <tr>
      <th>Client</th>
      <th>Reference</th>
      <th>Build Tag</th>
      <th>Default</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>net/http</td>
      <td>golang.org/pkg/net/http</td>
      <td><code class="highlighter-rouge">nethttp</code></td>
      <td>no</td>
    </tr>
    <tr>
      <td>fasthttp</td>
      <td>github.com/valyala/fasthttp</td>
      <td>n/a</td>
      <td>yes</td>
    </tr>
  </tbody>
</table>

<p>To test with net/http, run:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>go <span class="nb">test</span> <span class="nt">-v</span> <span class="nt">-tags</span><span class="o">=</span>nethttp
</code></pre></div></div>

<p>or, the same, with logs redirected to stdout:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nv">$ </span>go <span class="nb">test</span> <span class="nt">-v</span> <span class="nt">-logtostderr</span><span class="o">=</span><span class="nb">true</span> <span class="nt">-tags</span><span class="o">=</span>nethttp
</code></pre></div></div>

<p>For more examples, see <a href="#testing">testing</a> below.</p>

<h2 id="description">Description</h2>

<p>A <strong>stream</strong> (or, more exactly, a <code class="highlighter-rouge">transport.Stream</code>) asynchronously transfers <strong>objects</strong> between two HTTP endpoints.
The objects, in turn, are defined by their <strong>headers</strong> (<code class="highlighter-rouge">transport.Header</code>) and their <strong>readers</strong> (<a href="https://golang.org/pkg/io/#ReadCloser">io.ReadCloser</a>).</p>

<p>A stream preserves ordering: the objects posted for sending will get <em>completed</em> in the same exact order
(for more on <em>completions</em>, see below), and certainly transferred to the receiver in the same exact order as well.</p>

<table>
  <thead>
    <tr>
      <th>Term</th>
      <th>Description</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Stream</td>
      <td>A point-to-point flow over HTTP where a single HTTP request (and, therefore, a single TCP session) is used to transfer multiple objects</td>
      <td><code class="highlighter-rouge">transport.NewStream(client, "http://example.com", nil)</code> - creates a stream between the local client and the <code class="highlighter-rouge">example.com</code> host</td>
    </tr>
    <tr>
      <td>Object</td>
      <td>Any <a href="https://golang.org/pkg/io/#ReadCloser">io.ReadCloser</a> that is accompanied by a transport header that specifies, in part, the object’s size and the object’s (bucket, name) at the destination</td>
      <td><code class="highlighter-rouge">transport.Header{"abc", "X", nil, 1024*1024}</code> - specifies a 1MB object that will be named <code class="highlighter-rouge">abc/X</code> at the destination</td>
    </tr>
    <tr>
      <td>Object Attributes</td>
      <td>Objects are often associated with their attributes like size, access time, checksum and version. When sending the object it is often necessary to also send these attributes with the object so the receiver can update the object metadata.</td>
      <td><code class="highlighter-rouge">transport.ObjectAttrs{Atime: time.Now(), Size: 13, CksumType: "xxhash", Chksum: "s0m3ck5um", Version: "2"}</code></td>
    </tr>
    <tr>
      <td>Object Header</td>
      <td>A <code class="highlighter-rouge">transport.Header</code> structure that, in addition to bucket name, object name, and object size, carries an arbitrary (<em>opaque</em>) sequence of bytes that, for instance, may be a JSON message or anything else.</td>
      <td><code class="highlighter-rouge">transport.Header{"abracadabra", "p/q/s", false, []byte{'1', '2', '3'}, transport.ObjectAttrs{Size: 13}}</code> - describes a 13-byte object that, in the example, has some application-specific and non-nil <em>opaque</em> field in the header</td>
    </tr>
    <tr>
      <td>Receive callback</td>
      <td>A function that has the following signature: <code class="highlighter-rouge">Receive func(http.ResponseWriter, transport.Header, io.Reader)</code>. Receive callback must be <em>registered</em> prior to the very first object being transferred over the stream - see next.</td>
      <td>Notice the last parameter in the receive callback: <code class="highlighter-rouge">io.Reader</code>. Behind this (reading) interface, there’s a special type reader supporting, in part, object boundaries. In other words, each callback invocation corresponds to one transferred and received object. Note as well the object header that is also delivered to the receiving endpoint via the same callback.</td>
    </tr>
    <tr>
      <td>Registering receive callback</td>
      <td>An API to establish the one-to-one correspondence between the stream sender and the stream receiver</td>
      <td>For instance, to register the same receive callback <code class="highlighter-rouge">foo</code> with two different HTTP endpoints named “ep1” and “ep2”, we could call <code class="highlighter-rouge">transport.Register("n1", "ep1", foo)</code> and <code class="highlighter-rouge">transport.Register("n1", "ep2", foo)</code>, where <code class="highlighter-rouge">n1</code> is an http request multiplexer (“muxer”) that corresponds to one of the documented networking options - see <a href="README.md">README, section Networking</a>. The transport will then be calling <code class="highlighter-rouge">foo()</code> to separately deliver the “ep1” stream to the “ep1” endpoint and “ep2” - to, respectively, “ep2”. Needless to say that a per-endpoint callback is also supported and permitted. To allow registering endpoints to different http request multiplexers, one can change network parameter <code class="highlighter-rouge">transport.Register("different-network", "ep1", foo)</code></td>
    </tr>
    <tr>
      <td>Object-has-been-sent callback (not to be confused with the Receive callback above)</td>
      <td>A function or a method of the following signature: <code class="highlighter-rouge">SendCallback func(Header, io.ReadCloser, error)</code>, where <code class="highlighter-rouge">transport.Header</code> and <code class="highlighter-rouge">io.ReadCloser</code> represent the object that has been transmitted and error is the send error or nil</td>
      <td>This callback can optionally be defined on a) per-stream basis (via NewStream constructor) and/or b) for a given object that is being sent (for instance, to support some sort of batch semantics). Note that object callback <em>overrides</em> the per-stream one: when (object callback) is defined i.e., non-nil, the stream callback is ignored and skipped.<br /><br /><strong>BEWARE:</strong><br />Latency of this callback adds to the latency of the entire stream operation on the send side. It is critically important, therefore, that user implementations do not take extra locks, do not execute system calls and, generally, return as soon as possible.</td>
    </tr>
    <tr>
      <td>Header-only objects</td>
      <td>Header-only (data-less) objects are supported - when there’s no data to send (that is, when the <code class="highlighter-rouge">transport.Header.Dsize</code> field is set to zero), the reader (<code class="highlighter-rouge">io.ReadCloser</code>) is not required and the corresponding argument in the the <code class="highlighter-rouge">Send()</code> API can be set to nil</td>
      <td>Header-only objects can be used to implement L6 control plane over streams, where the header’s <code class="highlighter-rouge">Opaque</code> field gets utilized to transfer the entire (control message’s) payload</td>
    </tr>
    <tr>
      <td>Stream bundle</td>
      <td>A higher-level (cluster level) API to aggregate multiple streams and broadcast objects replicas to all or some of the established nodes of the cluster while aggregating completions and preserving FIFO ordering</td>
      <td><code class="highlighter-rouge">transport.NewStreamBundle(smap, si, client, transport.SBArgs{Network: transport.cmn.NetworkPublic, Trname: "path-name", Extra: &amp;extra, Ntype: cluster.Targets, ManualResync: false, Multiplier: 4})</code></td>
    </tr>
  </tbody>
</table>

<h2 id="closing-and-completions">Closing and completions</h2>

<p>In streams, the sending pipeline is implemented as a pair (SQ, SCQ) where the former is a send queue
realized as a channel, and the latter is a send completion queue (and a different Go channel).
Together, SQ and SCQ form a FIFO as far as ordering of transmitted objects.</p>

<p>Once an object is put on the wire, the corresponding completion gets queued and eventually gets
processed by the completion handler. The handling <strong>always entails closing of the object reader</strong>.</p>

<p>To reiterate: object reader is always closed by the code that handles <code class="highlighter-rouge">send completions</code>.
In the case when the callback (<code class="highlighter-rouge">SendCallback</code>) is provided (i.e., non-nil), the closing is done 
right after invoking the callback.</p>

<p>Note as well that for every transmission of every object there’s always a <em>completion</em>.
This holds true in all cases including network errors that may cause sudden and instant termination
of the underlying stream(s).</p>

<h2 id="commented-example">Commented example</h2>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">path</span> <span class="o">:=</span> <span class="n">transport</span><span class="o">.</span><span class="n">Register</span><span class="p">(</span><span class="s">"n1"</span><span class="p">,</span> <span class="s">"ep1"</span><span class="p">,</span> <span class="n">testReceive</span><span class="p">)</span> <span class="c">// register receive callback with HTTP endpoint "ep1" to "n1" network</span>
<span class="n">client</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">http</span><span class="o">.</span><span class="n">Client</span><span class="p">{</span><span class="n">Transport</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">http</span><span class="o">.</span><span class="n">Transport</span><span class="p">{}}</span> <span class="c">// create default HTTP client</span>
<span class="n">url</span> <span class="o">:=</span> <span class="s">"http://example.com/"</span> <span class="o">+</span>  <span class="n">path</span> <span class="c">// combine the hostname with the result of the Register() above</span>

<span class="c">// open a stream (to the http endpoint identified by the url) with burst equal 10 and the capability to cancel at any time</span>
<span class="c">// ("burst" is the number of objects the caller is permitted to post for sending without experiencing any sort of back-pressure)</span>
<span class="n">ctx</span><span class="p">,</span> <span class="n">cancel</span> <span class="o">:=</span> <span class="n">context</span><span class="o">.</span><span class="n">WithCancel</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">Background</span><span class="p">())</span>
<span class="n">stream</span> <span class="o">:=</span> <span class="n">transport</span><span class="o">.</span><span class="n">NewStream</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transport</span><span class="o">.</span><span class="n">Extra</span><span class="p">{</span><span class="n">Burst</span><span class="o">:</span> <span class="m">10</span><span class="p">,</span> <span class="n">Ctx</span><span class="o">:</span> <span class="n">ctx</span><span class="p">})</span>

<span class="c">// NOTE: constructing a transport stream does not necessarily entail establishing TCP connection.</span>
<span class="c">// Actual connection establishment is delayed until the very first object gets posted for sending.</span>
<span class="c">// The underlying HTTP/TCP session will also terminate after a (configurable) period of inactivity</span>
<span class="c">// (`Extra.IdleTimeout`), only to be re-established when (and if) the traffic picks up again.</span>

<span class="k">for</span>  <span class="p">{</span>
	<span class="n">hdr</span> <span class="o">:=</span> <span class="n">transport</span><span class="o">.</span><span class="n">Header</span><span class="p">{</span><span class="o">...</span><span class="p">}</span> 	<span class="c">// next object header</span>
	<span class="n">object</span> <span class="o">:=</span> <span class="o">...</span> 			<span class="c">// next object reader, e.g. os.Open("some file")</span>
	<span class="c">// send the object asynchronously (the 3rd arg specifies an optional "object-has-been-sent" callback)</span>
	<span class="n">stream</span><span class="o">.</span><span class="n">Send</span><span class="p">(</span><span class="n">hdr</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="no">nil</span><span class="p">)</span>
	<span class="o">...</span>
<span class="p">}</span>
<span class="n">stream</span><span class="o">.</span><span class="n">Fin</span><span class="p">()</span> <span class="c">// gracefully close the stream (call it in all cases except after canceling (aborting) the stream)</span>

</code></pre></div></div>
<h2 id="registering-http-endpoint">Registering HTTP endpoint</h2>

<p>On the receiving side, each network contains multiple HTTP endpoints, whereby each HTTP endpoint, in turn, may have zero or more stream sessions.
In effect, there are two nested many-to-many relationships whereby you may have multiple logical networks, each containing multiple named transports, etc.</p>

<p>The following:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">path</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">transport</span><span class="o">.</span><span class="n">Register</span><span class="p">(</span><span class="s">"public"</span><span class="p">,</span> <span class="s">"myapp"</span><span class="p">,</span> <span class="n">mycallback</span><span class="p">)</span>
</code></pre></div></div>

<p>adds a transport endpoint named “myapp” to the “public” network (that must already exist), and then registers a user callback with the latter.</p>

<p>The last argument, user-defined callback, must have the following typedef:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Receive</span> <span class="k">func</span><span class="p">(</span><span class="n">w</span> <span class="n">http</span><span class="o">.</span><span class="n">ResponseWriter</span><span class="p">,</span> <span class="n">hdr</span> <span class="n">Header</span><span class="p">,</span> <span class="n">object</span> <span class="n">io</span><span class="o">.</span><span class="n">Reader</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div></div>

<p>The callback is being invoked on a per received object basis (note that a single stream may transfer multiple, potentially unlimited, number of objects).
Callback is always invoked in case of an error.</p>

<p>Back to the registration. On the HTTP receiving side, the call to <code class="highlighter-rouge">Register</code> translates as:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mux</span><span class="o">.</span><span class="n">HandleFunc</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">mycallback</span><span class="p">)</span>
</code></pre></div></div>
<p>where mux is <code class="highlighter-rouge">mux.ServeMux</code> (fork of <code class="highlighter-rouge">net/http</code> package) that corresponds to the named network (“public”, in this example), and path is a URL path ending with “/myapp”.</p>

<h2 id="on-the-wire">On the wire</h2>

<p>On the wire, each transmitted object will have the layout:</p>

<blockquote>
  <blockquote>
    <p>[header length] [header fields including object name and size] [object bytes]</p>
  </blockquote>
</blockquote>

<p>The size must be known upfront, which is the current limitation.</p>

<p>A stream (the <a href="/transport/send.go">Stream type</a>) carries a sequence of objects of arbitrary sizes and contents, and overall looks as follows:</p>

<blockquote>
  <blockquote>
    <p>object1 = (<strong>[header1]</strong>, <strong>[data1]</strong>) object2 = (<strong>[header2]</strong>, <strong>[data2]</strong>), etc.</p>
  </blockquote>
</blockquote>

<p>Stream termination is denoted by a special marker in the data-size field of the header:</p>

<blockquote>
  <blockquote>
    <p>header = [object size=7fffffffffffffff]</p>
  </blockquote>
</blockquote>

<h2 id="transport-statistics">Transport statistics</h2>

<p>The API that queries runtime statistics includes:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">Stream</span><span class="p">)</span> <span class="n">GetStats</span><span class="p">()</span> <span class="p">(</span><span class="n">stats</span> <span class="n">Stats</span><span class="p">)</span>
</code></pre></div></div>
<ul>
  <li>on the send side, and</li>
</ul>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">GetNetworkStats</span><span class="p">(</span><span class="n">network</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="n">netstats</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="n">EndpointStats</span><span class="p">,</span> <span class="n">err</span> <span class="kt">error</span><span class="p">)</span>
</code></pre></div></div>
<ul>
  <li>on receive.</li>
</ul>

<p>Statistics themselves include the following metrics:</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stats</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">Num</span>     <span class="kt">int64</span>   <span class="c">// number of transferred objects</span>
	<span class="n">Size</span>    <span class="kt">int64</span>   <span class="c">// transferred size, in bytes</span>
	<span class="n">Offset</span>  <span class="kt">int64</span>   <span class="c">// stream offset, in bytes</span>
	<span class="n">IdleDur</span> <span class="kt">int64</span>   <span class="c">// the time stream was idle since the previous GetStats call</span>
	<span class="n">TotlDur</span> <span class="kt">int64</span>   <span class="c">// total time since the previous GetStats</span>
	<span class="n">IdlePct</span> <span class="kt">float64</span> <span class="c">// idle time %</span>
<span class="p">}</span>

</code></pre></div></div>

<p>On the receive side, the <code class="highlighter-rouge">EndpointStats</code> map contains all the <code class="highlighter-rouge">transport.Stats</code> structures indexed by (unique) stream IDs for the currently active streams.</p>

<p>For usage examples and details, please see tests in the package directory.</p>

<h2 id="stream-bundle">Stream Bundle</h2>

<p>Stream bundle (<code class="highlighter-rouge">transport.StreamBundle</code>) in this package is motivated by the need to broadcast and multicast continuously over a set of long-lived TCP sessions. The scenarios in storage clustering include intra-cluster replication and erasure coding, rebalancing (upon <em>target-added</em> and <em>target-removed</em> events) and MapReduce-generated flows, and more.</p>

<p>In each specific case, a given clustered node needs to maintain control and/or data flows between itself and multiple other clustered nodes, where each of the flows would be transferring large numbers of control and data objects, or parts of thereof.</p>

<p>The provided implementation aggregates transport streams. A stream (or, a <code class="highlighter-rouge">transport.Stream</code>) asynchronously transfers <em>objects</em> between two HTTP endpoints, whereby an object is defined as a combination of <code class="highlighter-rouge">transport.Header</code> and an (<a href="https://golang.org/pkg/io/#ReadCloser">io.ReadCloser</a>) interface. The latter may have a variety of well-known implementations: file, byte array, scatter-gather list of buffers, etc.</p>

<p>The important distinction, though, is that while transport streams are devoid of any clustering “awareness”, a <em>stream bundle</em> is fully integrated with a cluster. Internally, the implementation utilizes cluster-level abstractions, such as a <em>node</em> (<code class="highlighter-rouge">cluster.Snode</code>), a <em>cluster map</em> (<code class="highlighter-rouge">cluster.Smap</code>), and more.</p>

<p>The provided API includes <code class="highlighter-rouge">StreamBundle</code> constructor that allows to establish streams between the local node and (a) all storage targets, (b) all gateways, or (c) all nodes in the cluster - in one shot:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sbArgs := &amp;SBArgs{
  Network	string,		// network, one of `cmn.KnownNetworks`
  Trname	string,		// transport endpoint name
  Extra		*Extra, // additional stream control parameters
  Ntype 	int,		// destination type: all targets, ..., all nodes
  ManualResync bool,		// if false, establishes/removes connections with new/old nodes when new smap is received
  Multiplier int,		// number of streams per destination, with subsequent round-robin selection
}

NewStreamBundle(
  sowner	cluster.Sowner,		// Smap (cluster map) owner interface
  lsnode	*cluster.Snode,		// local node
  cl		*http.Client,		// http client
  sbArgs	*SbArgs			// additional stream bundle arguments
)
</code></pre></div></div>

<h3 id="a-note-on-connection-establishment-and-termination">A note on connection establishment and termination</h3>

<blockquote>
  <blockquote>
    <p>For each of the individual transport streams in a bundle, constructing a stream (<code class="highlighter-rouge">transport.Stream</code>) does not necessarily entail establishing TCP connection. Actual connection establishment is delayed until arrival (via <code class="highlighter-rouge">Send</code> or <code class="highlighter-rouge">SendV</code>) of the very first object.</p>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <p>The underlying HTTP/TCP session will also terminate after a (configurable) period of inactivity, only to be re-established when (and if) the traffic picks up again.</p>
  </blockquote>
</blockquote>

<h3 id="api">API</h3>

<p>The two main API methods are <code class="highlighter-rouge">Send</code> and <code class="highlighter-rouge">SendV</code>:</p>

<ul>
  <li>to broadcast via all established streams, use <code class="highlighter-rouge">SendV()</code> and omit the last argument;</li>
  <li>otherwise, use <code class="highlighter-rouge">SendV()</code> with the destinations specified as a comma-separated list, or</li>
  <li>use <code class="highlighter-rouge">Send()</code> with a list of nodes on the receive side.</li>
</ul>

<p>Other provided APIs include terminating all contained streams - gracefully or instantaneously via <code class="highlighter-rouge">Close</code>, and more.</p>

<p>Finally, there are two important facts to remember:</p>

<ul>
  <li>
    <p>When streaming an object to multiple destinations, <code class="highlighter-rouge">StreamBundle</code> may call <code class="highlighter-rouge">reader.Open()</code> multiple times as well. For N object replicas (or N identical notifications) over N streams, the original reader (provided via <code class="highlighter-rouge">Send</code> or <code class="highlighter-rouge">SendV</code> - see above) will get reopened (N-1) times.</p>
  </li>
  <li>
    <p>Completion callback (<code class="highlighter-rouge">transport.SendCallback</code>), if provided, is getting called only once per object, independently of the number of the object replicas sent to multiple destinations. The callback is invoked by the completion handler of the very last object replica (for more on completion handling.</p>
  </li>
</ul>

<h2 id="testing">Testing</h2>

<ul>
  <li>To run all tests while redirecting log to STDERR:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go test -v -logtostderr=true
</code></pre></div>    </div>
  </li>
  <li>To run a test with a name matching “Multi”, verbose logging and enabled assertions:
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AIS_DEBUG=transport=1 go test -v -run=Multi
</code></pre></div>    </div>
  </li>
</ul>

<p>Use <code class="highlighter-rouge">nethttp</code> build tag to run with net/http, e.g.:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>go <span class="nb">test</span> <span class="nt">-v</span> <span class="nt">-tags</span><span class="o">=</span>nethttp
</code></pre></div></div>

<p>The same with fasthttp (which is the current default):</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>go <span class="nb">test</span> <span class="nt">-v</span>
</code></pre></div></div>

<p>For more examples, please see tests in the package directory.</p>

<h2 id="environment">Environment</h2>

<table>
  <thead>
    <tr>
      <th>Environment Variable</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>AIS_DEBUG</td>
      <td>Enable inline assertions and verbose tracing (eg. <code class="highlighter-rouge">AIS_DEBUG=transport=1</code>)</td>
    </tr>
    <tr>
      <td>AIS_STREAM_BURST_NUM</td>
      <td>Max number of objects the caller is permitted to post for sending without experiencing any sort of back-pressure</td>
    </tr>
    <tr>
      <td>AIS_STREAM_DRY_RUN</td>
      <td>If enabled, read and immediately discard all read data (can be used to evaluate client-side throughput)</td>
    </tr>
  </tbody>
</table>


  </div><a class="u-url" href="/aistore/transport" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/aistore/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">AIStore - distributed object storage</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">AIStore - distributed object storage</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>AIStore is a lightweight object storage system with the capability to linearly scale-out with each added storage node and a special focus on petascale deep learning. See more at: github.com/NVIDIA/aistore
</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
