<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>HOWTO_BENCHMARK | AIStore - distributed object storage</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="HOWTO_BENCHMARK" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="AIStore is a lightweight object storage system with the capability to linearly scale-out with each added storage node and a special focus on petascale deep learning. See more at: github.com/NVIDIA/aistore" />
<meta property="og:description" content="AIStore is a lightweight object storage system with the capability to linearly scale-out with each added storage node and a special focus on petascale deep learning. See more at: github.com/NVIDIA/aistore" />
<link rel="canonical" href="http://localhost:4000/aistore/docs/howto_benchmark" />
<meta property="og:url" content="http://localhost:4000/aistore/docs/howto_benchmark" />
<meta property="og:site_name" content="AIStore - distributed object storage" />
<script type="application/ld+json">
{"headline":"HOWTO_BENCHMARK","@type":"WebPage","url":"http://localhost:4000/aistore/docs/howto_benchmark","description":"AIStore is a lightweight object storage system with the capability to linearly scale-out with each added storage node and a special focus on petascale deep learning. See more at: github.com/NVIDIA/aistore","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/aistore/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/aistore/feed.xml" title="AIStore - distributed object storage" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/aistore/">AIStore - distributed object storage</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">HOWTO_BENCHMARK</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="" itemprop="datePublished">
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="table-of-contents">Table of Contents</h2>
<ul>
  <li><a href="#ais-loader">AIS Loader</a>
    <ul>
      <li><a href="#examples">Examples</a></li>
      <li><a href="#command-line-options">Command-line options</a></li>
      <li><a href="#cluster-under-test">Cluster Under Test</a></li>
      <li><a href="#ais-vs-cloud-based-bucket">AIS vs Cloud-based bucket</a></li>
      <li><a href="#duration">Duration</a></li>
      <li><a href="#write-vs-read">Write vs Read</a></li>
      <li><a href="#read-range">Read range</a></li>
      <li><a href="#cleanup">Cleanup</a></li>
      <li><a href="#object-size">Object size</a></li>
      <li><a href="#grafana-and-graphite">Grafana and Graphite</a></li>
    </ul>
  </li>
</ul>

<h2 id="ais-loader">AIS Loader</h2>

<p>AIS Loader (<code class="highlighter-rouge">aisloader</code>) is a tool to measure storage performance. It’s a load generator that has been developed (and is currently used) to benchmark and stress-test AIStore(tm) but can be easily extended for any S3-compatible backend.</p>

<p>For usage, run: <code class="highlighter-rouge">aisloader</code> or <code class="highlighter-rouge">aisloader usage</code> or <code class="highlighter-rouge">aisloader --help</code>.</p>

<p>To get started, cd to <a href="/bench/aisloader/">aisloader home</a> and run:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./install.sh
<span class="nv">$ $GOPATH</span>/bin/aisloader
</code></pre></div></div>
<h3 id="examples">Examples</h3>

<p>For the most recently updated command-line options and examples, please run <code class="highlighter-rouge">aisloader</code> or <code class="highlighter-rouge">aisloader usage</code>.</p>

<ol>
  <li>Destroy existing ais bucket. If the bucket is Cloud-based, delete all objects:
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># aisloader -bucket=nvais -duration 0s -totalputsize=0</span>
</code></pre></div>    </div>
  </li>
  <li>Time-based 100% PUT into ais bucket. Upon exit the bucket is emptied (by default):
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># aisloader -bucket=nvais -duration 10s -numworkers=3 -minsize=1K -maxsize=1K -pctput=100 -provider=ais</span>
</code></pre></div>    </div>
  </li>
  <li>Timed (for 1h) 100% GET from a Cloud bucket, no cleanup:
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>aisloader <span class="nt">-bucket</span><span class="o">=</span>nvaws <span class="nt">-duration</span> 1h <span class="nt">-numworkers</span><span class="o">=</span>30 <span class="nt">-pctput</span><span class="o">=</span>0 <span class="nt">-provider</span><span class="o">=</span>cloud <span class="nt">-cleanup</span><span class="o">=</span><span class="nb">false</span>
</code></pre></div>    </div>
  </li>
  <li>Mixed 30%/70% PUT and GET of variable-size objects to/from a Cloud bucket. PUT will generate random object names and is limited by the 10GB total size. Cleanup is not disabled, which means that upon completion all generated objects will be deleted:
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># aisloader -bucket=nvaws -duration 0s -numworkers=3 -minsize=1024 -maxsize=1MB -pctput=30 -provider=cloud -totalputsize=10G</span>
</code></pre></div>    </div>
  </li>
  <li>PUT 1GB total into an ais bucket with cleanup disabled, object size = 1MB, duration unlimited:
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># aisloader -bucket=nvais -cleanup=false -totalputsize=1G -duration=0 -minsize=1MB -maxsize=1MB -numworkers=8 -pctput=100 -provider=ais</span>
</code></pre></div>    </div>
  </li>
  <li>100% GET from an ais bucket:
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># aisloader -bucket=nvais -duration 5s -numworkers=3 -pctput=0 -provider=ais</span>
</code></pre></div>    </div>
  </li>
  <li>PUT 2000 objects named as `aisloader/hex({0..2000}{loaderid}):
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># aisloader -bucket=nvais -duration 10s -numworkers=3 -loaderid=11 -loadernum=20 -maxputs=2000 -objNamePrefix="aisloader"</span>
</code></pre></div>    </div>
  </li>
  <li>Use random object names and loaderID to report statistics:
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># aisloader -loaderid=10</span>
</code></pre></div>    </div>
  </li>
  <li>PUT objects with random name generation being based on the specified loaderID and the total number of concurrent aisloaders:
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># aisloader -loaderid=10 -loadernum=20</span>
</code></pre></div>    </div>
  </li>
  <li>Same as above except that loaderID is computed by the aisloader as hash(loaderstring) &amp; 0xff:
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># aisloader -loaderid=loaderstring -loaderidhashlen=8</span>
</code></pre></div>    </div>
  </li>
  <li>Print loaderID and exit (all 3 examples below) with the resulting loaderID shown on the right:
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># aisloader -getloaderid (0x0)</span>
<span class="c"># aisloader -loaderid=10 -getloaderid (0xa)</span>
<span class="c"># aisloader -loaderid=loaderstring -loaderidhashlen=8 -getloaderid (0xdb)</span>
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="command-line-options">Command-line Options</h3>

<p>For the most recently updated command-line options and examples, please run <code class="highlighter-rouge">aisloader</code> or <code class="highlighter-rouge">aisloader usage</code>.</p>

<table>
  <thead>
    <tr>
      <th>Command-line option</th>
      <th>Description</th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>-batchsize</td>
      <td>Batch size to list and delete (default 100)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-provider</td>
      <td>ais - for AIS, cloud - for Cloud bucket; other supported values include “gcp” and “aws”, for Amazon and Google clouds, respectively (default “ais”)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-bprops</td>
      <td>JSON string formatted as per the SetBucketProps API and containing bucket properties to apply</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-bucket</td>
      <td>Bucket name (default “nvais”)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-check-statsd</td>
      <td>true: prior to benchmark make sure that StatsD is reachable</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-cleanup</td>
      <td>true: remove all created objects upon benchmark termination (default true)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-dry-run</td>
      <td>show the configuration and parameters that aisloader will use</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-duration</td>
      <td>Benchmark duration (0 - run forever or until Ctrl-C, default 1m). Note that if both duration and totalputsize are zeros, aisloader will have nothing to do</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-getconfig</td>
      <td>true: generate control plane load by reading AIS proxy configuration (that is, instead of reading/writing data exercise control path)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-getloaderid</td>
      <td>true: print stored/computed unique loaderID aka aisloader identifier and exit</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-ip</td>
      <td>AIS proxy/gateway IP address or hostname (default “localhost”)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-json</td>
      <td>true: print the output in JSON</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-loaderid</td>
      <td>ID to identify a loader among multiple concurrent instances (default “0”)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-loaderidhashlen</td>
      <td>Size (in bits) of the generated aisloader identifier. Cannot be used together with loadernum</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-loadernum</td>
      <td>total number of aisloaders running concurrently and generating combined load. If defined, must be greater than the loaderid and cannot be used together with loaderidhashlen</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-maxputs</td>
      <td>Maximum number of objects to PUT</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-maxsize</td>
      <td>Maximum object size (with or without multiplicative suffix K, MB, GiB, etc.)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-minsize</td>
      <td>Minimum object size (with or without multiplicative suffix K, MB, GiB, etc.)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-numworkers</td>
      <td>Number of goroutine workers operating on AIS in parallel (default 10)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-pctput</td>
      <td>Percentage of PUTs in the aisloader-generated workload</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-port</td>
      <td>Percentage of PUTs in the aisloader-generated workload</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-randomname</td>
      <td>true: generate object names of 32 random characters. This option is ignored when loadernum is defined (default true)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-readertype</td>
      <td>Type of reader: sg(default)</td>
      <td>file</td>
      <td>rand (default “sg”)</td>
    </tr>
    <tr>
      <td>-readlen</td>
      <td>Read range length (can contain multiplicative suffix; 0 - GET full object)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-readoff</td>
      <td>Read range offset (can contain multiplicative suffix K, MB, GiB, etc.)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-seed</td>
      <td>Random seed to achieve deterministic reproducible results (0 - use current time in nanoseconds)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-stats-output</td>
      <td>filename to log statistics (empty string translates as standard output (default)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-statsdip</td>
      <td>StatsD IP address or hostname (default “localhost”)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-statsdport</td>
      <td>StatsD UDP port (default 8125)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-statsinterval</td>
      <td>Interval in seconds to print performance counters; 0 - disabled (default 10 seconds)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-subdir</td>
      <td>Virtual destination directory for all aisloader-generated objects</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-tmpdir</td>
      <td>Local directory to store temporary files (default “/tmp/ais”)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-totalputsize</td>
      <td>Stop PUT workload once cumulative PUT size reaches or exceeds this value (can contain standard multiplicative suffix K, MB, GiB, etc.), 0 - unlimited</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-uniquegets</td>
      <td>true: GET objects randomly and equally. Meaning, make sure <em>not</em> to GET some objects more frequently than the others (default true)</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-usage</td>
      <td>Show command-line options, usage, and examples</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>-verifyhash</td>
      <td>checksum-validate GET: recompute object checksums and validate it against the one received with the GET metadata</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h3 id="cluster-under-test">Cluster Under Test</h3>

<p>By default, <code class="highlighter-rouge">aisloader</code> sends its requests to the localhost at http://127.0.0.1:8080. To specify the primary proxy URL, use the <code class="highlighter-rouge">ip</code> and <code class="highlighter-rouge">port</code> command line options, as follows:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">ip</span><span class="o">=</span>&lt;IPv4 or <span class="nb">hostname </span>of the current primary proxy&gt;
<span class="nv">port</span><span class="o">=</span>&lt;TCP port&gt;
</code></pre></div></div>

<p>For example:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>aisloader <span class="nt">-ip</span><span class="o">=</span>example.com <span class="nt">-port</span><span class="o">=</span>8080

Starting GMem2, minfree 3.62GiB, low 7.24GiB, timer 1m0s
GMem2: free memory 7.24GiB <span class="o">&gt;</span> 80% total
Nothing to <span class="nb">read</span>, bucket is empty
</code></pre></div></div>

<h3 id="ais-vs-cloud-based-bucket">AIS vs Cloud-based bucket</h3>

<p>In the example above, the “nothing to read” indicates that <code class="highlighter-rouge">aistore</code> requires a bucket to operate upon. Use the switch ‘-ais’ to select between ais bucket (<code class="highlighter-rouge">-ais=true</code>) or Cloud-based one (<code class="highlighter-rouge">-ais=false</code>).</p>

<blockquote>
  <p>Terminology: the term <em>ais bucket</em> simply means that the bucket in question does <strong>not</strong> cache (or tier) 3rd party Cloud and is not backed by the namesake Cloud bucket. AIS buckets are distributed across the entire AIS cluster. All the <a href="/docs/storage_svcs.md">supported storage services</a> equally apply to both sorts of buckets.</p>
</blockquote>

<p>Note that aisloader <strong>will create an ais bucket if it does not exist</strong>.</p>

<p>Further, the name of the bucket is set via the option <code class="highlighter-rouge">-bucket=&lt;bucket name&gt;</code>.
For instance:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ aisloader -ip=example.com -port=8080 -bucket=abc -provider=ais
</code></pre></div></div>

<h3 id="duration">Duration</h3>

<p>The loads can run for a given period of time (option <code class="highlighter-rouge">-duration &lt;duration&gt;</code>) or until the specified amount of data is generated (option <code class="highlighter-rouge">-totalputsize=&lt;total size in KBs&gt;</code>).</p>

<p>If both options are provided the test finishes on the whatever-comes-first basis.</p>

<p>Example 100% write into the bucket “abc” for 2 hours:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>aisloader <span class="nt">-bucket</span><span class="o">=</span>abc <span class="nt">-provider</span><span class="o">=</span>ais <span class="nt">-duration</span> 2h <span class="nt">-totalputsize</span><span class="o">=</span>4000000 <span class="nt">-pctput</span><span class="o">=</span>100
</code></pre></div></div>

<p>The above will run for two hours or until it writes around 4GB data into the bucket, whatever comes first.</p>

<h3 id="write-vs-read">Write vs Read</h3>

<p>You can choose a percentage of writing (versus reading) by setting the option <code class="highlighter-rouge">-pctput=&lt;put percentage&gt;</code>.</p>

<p>Example with a mixed PUT=30% and GET=70% load:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>aisloader <span class="nt">-bucket</span><span class="o">=</span>abc <span class="nt">-duration</span> 5m <span class="nt">-pctput</span><span class="o">=</span>30
</code></pre></div></div>

<p>Example 100% PUT:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>aisloader <span class="nt">-bucket</span><span class="o">=</span>abc <span class="nt">-duration</span> 5m <span class="nt">-pctput</span><span class="o">=</span>100
</code></pre></div></div>

<p>The duration in both examples above is set to 5 minutes.</p>

<blockquote>
  <p>To test 100% read (<code class="highlighter-rouge">-pctput=0</code>), make sure to fill the bucket beforehand.</p>
</blockquote>

<h4 id="read-range">Read range</h4>

<p>The loader can read the entire object (default) <strong>or</strong> a range of object bytes.</p>

<p>To set the offset and length to read, use option <code class="highlighter-rouge">-readoff=&lt;read offset (in bytes)&gt;</code> and <code class="highlighter-rouge">readlen=&lt;length to read (in bytes)&gt;</code>.</p>

<p>For convenience, both options support size suffixes: <code class="highlighter-rouge">k</code> - for KiB, <code class="highlighter-rouge">m</code> - for MiB, and <code class="highlighter-rouge">g</code> - for GiB.</p>

<p>Example that reads a 32MiB segment at 1KB offset from each object stored in the bucket “abc”:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>aisloader <span class="nt">-bucket</span><span class="o">=</span>abc <span class="nt">-duration</span> 5m <span class="nt">-cleanup</span><span class="o">=</span><span class="nb">false</span> <span class="nt">-readoff</span><span class="o">=</span>1024 <span class="nt">-readlen</span><span class="o">=</span>32m
</code></pre></div></div>

<p>The test (above) will run for 5 minutes and will not “cleanup” after itself (next section).</p>

<h3 id="cleanup">Cleanup</h3>

<p>By default, <code class="highlighter-rouge">aisloder</code> deletes all the data after completing its run. But what if, for instance, you’d want to test reads (<code class="highlighter-rouge">pctput=0</code>) after having populated the cluster via 100% PUT.</p>

<p>In this and similar cases, disable automatic cleanup by passing the option <code class="highlighter-rouge">cleanup=false</code>.</p>

<p>Example:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>aisloader <span class="nt">-bucket</span><span class="o">=</span>abc <span class="nt">-pctput</span><span class="o">=</span>100 <span class="nt">-totalputsize</span><span class="o">=</span>16348 <span class="nt">-cleanup</span><span class="o">=</span><span class="nb">false</span>
<span class="nv">$ </span>aisloader <span class="nt">-bucket</span><span class="o">=</span>abc <span class="nt">-duration</span> 1h <span class="nt">-pctput</span><span class="o">=</span>0 <span class="nt">-cleanup</span><span class="o">=</span><span class="nb">true</span>
</code></pre></div></div>

<p>The first line in this example above fills the bucket “abc” with 16MiB of random data. The second - uses existing data to test read performance for 1 hour, and then removes all data.</p>

<p>If you just need to clean up old data prior to running a test, run the loader with 0 (zero) total put size and zero duration:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>aisloader <span class="nt">-bucket</span><span class="o">=</span>&lt;bucket to cleanup&gt; <span class="nt">-duration</span> 0s <span class="nt">-totalputsize</span><span class="o">=</span>0
</code></pre></div></div>

<h3 id="object-size">Object size</h3>

<p>For the PUT workload the loader generates randomly-filled objects. But what about object sizing?</p>

<p>By default, object sizes are randomly selected as well in the range between 1MiB and 1GiB. To set preferred (or fixed) object size(s), use the options <code class="highlighter-rouge">-minsize=&lt;minimal object size in KiB&gt;</code> and <code class="highlighter-rouge">-maxsize=&lt;maximum object size in KiB&gt;</code></p>

<h3 id="setting-bucket-properties">Setting bucket properties</h3>

<p>Before starting a test, it is possible to set <code class="highlighter-rouge">mirror</code> or <code class="highlighter-rouge">EC</code> properties on a bucket (for background, please see <a href="/docs/storage_svcs.md">storage services</a>).</p>

<blockquote>
  <p>For background on local mirroring and erasure coding (EC), please see <a href="/docs/storage_svcs.md">storage services</a>.</p>
</blockquote>

<p>To achieve that, use the option <code class="highlighter-rouge">-bprops</code>. For example:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>aisloader <span class="nt">-bucket</span><span class="o">=</span>abc <span class="nt">-pctput</span><span class="o">=</span>0 <span class="nt">-cleanup</span><span class="o">=</span><span class="nb">false</span> <span class="nt">-duration</span> 10s <span class="nt">-bprops</span><span class="o">=</span><span class="s1">'{"mirror": {"copies": 2, "enabled": false, "util_thresh": 5}, "ec": {"enabled": false, "data_slices": 2, "parity_slices": 2}}'</span>
</code></pre></div></div>

<p>The above example shows the values that are globally default as of the AIS version 2.0. You can omit the defaults and specify only those values that you’d want to change. For instance, to enable erasure coding on the bucket “abc”:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>aisloader <span class="nt">-bucket</span><span class="o">=</span>abc <span class="nt">-duration</span> 10s <span class="nt">-bprops</span><span class="o">=</span><span class="s1">'{"ec": {"enabled": true}}'</span>
</code></pre></div></div>

<p>This example sets the number of data and parity slices to 2 which, in turn, requires the cluster to have at least 5 target nodes: 2 for data slices, 2 for parity slices and one for the original object.</p>

<blockquote>
  <p>As of v2.0, once erasure coding is enabled, its properties <code class="highlighter-rouge">data_slices</code> and <code class="highlighter-rouge">parity_slices</code> cannot be changed on the fly.</p>
</blockquote>

<p>The following sequence populates a bucket configured for both local mirroring and erasure coding, and then reads from it for 1h:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Fill bucket</span>
<span class="nv">$ </span>aisloader <span class="nt">-bucket</span><span class="o">=</span>abc <span class="nt">-cleanup</span><span class="o">=</span><span class="nb">false</span> <span class="nt">-pctput</span><span class="o">=</span>100 <span class="nt">-duration</span> 100m <span class="nt">-bprops</span><span class="o">=</span><span class="s1">'{"mirror": {"enabled": true}, "ec": {"enabled": true}}'</span>

<span class="c"># Read</span>
<span class="nv">$ </span>aisloader <span class="nt">-bucket</span><span class="o">=</span>abc <span class="nt">-cleanup</span><span class="o">=</span><span class="nb">false</span> <span class="nt">-pctput</span><span class="o">=</span>0 <span class="nt">-duration</span> 1h
</code></pre></div></div>

<h3 id="grafana-and-graphite">Grafana and Graphite</h3>

<p>The loader runs StatsD client and, therefore, can be easily used in conjunction with <a href="https://grafana.com">Grafana</a> or Graphite.</p>

<p>The local UDP port that <code class="highlighter-rouge">aisloader</code> uses to send its own collected statistics is the default 8125 (configurable via <code class="highlighter-rouge">-statsdport=&lt;statsd daemon port number&gt;</code>).</p>

  </div><a class="u-url" href="/aistore/docs/howto_benchmark" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/aistore/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">AIStore - distributed object storage</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">AIStore - distributed object storage</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>AIStore is a lightweight object storage system with the capability to linearly scale-out with each added storage node and a special focus on petascale deep learning. See more at: github.com/NVIDIA/aistore
</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
