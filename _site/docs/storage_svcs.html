<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>STORAGE_SVCS | AIStore - distributed object storage</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="STORAGE_SVCS" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="AIStore is a lightweight object storage system with the capability to linearly scale-out with each added storage node and a special focus on petascale deep learning. See more at: github.com/NVIDIA/aistore" />
<meta property="og:description" content="AIStore is a lightweight object storage system with the capability to linearly scale-out with each added storage node and a special focus on petascale deep learning. See more at: github.com/NVIDIA/aistore" />
<link rel="canonical" href="http://localhost:4000/aistore/docs/storage_svcs" />
<meta property="og:url" content="http://localhost:4000/aistore/docs/storage_svcs" />
<meta property="og:site_name" content="AIStore - distributed object storage" />
<script type="application/ld+json">
{"headline":"STORAGE_SVCS","@type":"WebPage","url":"http://localhost:4000/aistore/docs/storage_svcs","description":"AIStore is a lightweight object storage system with the capability to linearly scale-out with each added storage node and a special focus on petascale deep learning. See more at: github.com/NVIDIA/aistore","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/aistore/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/aistore/feed.xml" title="AIStore - distributed object storage" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/aistore/">AIStore - distributed object storage</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">STORAGE_SVCS</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="" itemprop="datePublished">
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="table-of-contents">Table of Contents</h2>
<ul>
  <li><a href="#storage-services">Storage Services</a>
    <ul>
      <li><a href="#notation">Notation</a></li>
    </ul>
  </li>
  <li><a href="#checksumming">Checksumming</a></li>
  <li><a href="#lru">LRU</a></li>
  <li><a href="#erasure-coding">Erasure coding</a></li>
  <li><a href="#n-way-mirror">N-way mirror</a>
    <ul>
      <li><a href="#read-load-balancing">Read load balancing</a></li>
      <li><a href="#more-examples">More examples</a></li>
    </ul>
  </li>
</ul>

<h2 id="storage-services">Storage Services</h2>

<p>By default, buckets inherit <a href="/ais/setup/config.sh">global configuration</a>. However, several distinct sections of this global configuration can be overridden at startup or at runtime on a per bucket basis. The list includes checksumming, LRU, erasure coding, and local mirroring - please see the following sections for details.</p>

<h3 id="notation">Notation</h3>

<p>In this document, <code class="highlighter-rouge">G</code> - denotes a (hostname:port) pair of any gateway in the AIS cluster.</p>

<h2 id="checksumming">Checksumming</h2>

<p>Checksumming on bucket level is configured by setting bucket properties:</p>

<ul>
  <li><code class="highlighter-rouge">cksum.type</code>: <code class="highlighter-rouge">"none"</code>,<code class="highlighter-rouge">"xxhash"</code> or <code class="highlighter-rouge">"inherit"</code> configure hashing type. Value
<code class="highlighter-rouge">"inherit"</code> indicates that the global checksumming configuration should be used.</li>
  <li><code class="highlighter-rouge">cksum.validate_cold_get</code>: <code class="highlighter-rouge">true</code> or <code class="highlighter-rouge">false</code> indicates
whether to perform checksum validation during cold GET.</li>
  <li><code class="highlighter-rouge">cksum.validate_warm_get</code>: <code class="highlighter-rouge">true</code> or <code class="highlighter-rouge">false</code> indicates
whether to perform checksum validation during warm GET.</li>
  <li><code class="highlighter-rouge">cksum.enable_read_range</code>: <code class="highlighter-rouge">true</code> or <code class="highlighter-rouge">false</code> indicates whether to perform checksum validation during byte serving.</li>
</ul>

<p>Value for the <code class="highlighter-rouge">type</code> field (see above) <em>must</em> be provided <em>every</em> time the bucket properties are updated, otherwise, the request will be rejected.</p>

<p>Example of setting bucket properties:</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl <span class="nt">-i</span> <span class="nt">-X</span> PUT <span class="nt">-H</span> <span class="s1">'Content-Type: application/json'</span> <span class="nt">-d</span> <span class="s1">'{"action":"setprops", "value": {"cksum": {"type": "xxhash", "validate_cold_get": true, "validate_warm_get": false, "enable_read_range": false}}}'</span> <span class="s1">'http://G/v1/buckets/&lt;bucket-name&gt;'</span>
</code></pre></div></div>

<h2 id="lru">LRU</h2>

<p>Overriding the global configuration can be achieved by specifying the fields of the <code class="highlighter-rouge">LRU</code> instance of the <code class="highlighter-rouge">LRUConf</code> struct that encompasses all LRU configuration fields.</p>

<ul>
  <li><code class="highlighter-rouge">lru.lowwm</code>: integer in the range [0, 100], representing the capacity usage low watermark</li>
  <li><code class="highlighter-rouge">lru.highwm</code>: integer in the range [0, 100], representing the capacity usage high watermark</li>
  <li><code class="highlighter-rouge">lru.atime_cache_max</code>: positive integer representing the maximum number of entries</li>
  <li><code class="highlighter-rouge">lru.dont_evict_time</code>: string that indicates eviction-free period [atime, atime + dont]</li>
  <li><code class="highlighter-rouge">lru.capacity_upd_time</code>: string indicating the minimum time to update capacity</li>
  <li><code class="highlighter-rouge">lru.enabled</code>: bool that determines whether LRU is run or not; only runs when true</li>
</ul>

<p><strong>NOTE</strong>: In setting bucket properties for LRU, any field that is not explicitly specified defaults to the data type’s zero value.</p>

<p>Example of setting bucket properties:</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl <span class="nt">-i</span> <span class="nt">-X</span> PUT <span class="nt">-H</span> <span class="s1">'Content-Type: application/json'</span> <span class="nt">-d</span> <span class="s1">'{"action":"setprops","value":{"cksum":{"type":"none","validate_cold_get":true,"validate_warm_get":true,"enable_read_range":true},"lru":{"lowwm":1,"highwm":100,"atime_cache_max":1,"dont_evict_time":"990m","capacity_upd_time":"90m","enabled":true}}}'</span> <span class="s1">'http://G/v1/buckets/&lt;bucket-name&gt;'</span>
</code></pre></div></div>

<p>To revert a bucket’s entire configuration back to use global parameters, use <code class="highlighter-rouge">"action":"resetprops"</code> to the same PUT endpoint as above as such:</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl <span class="nt">-i</span> <span class="nt">-X</span> PUT <span class="nt">-H</span> <span class="s1">'Content-Type: application/json'</span> <span class="nt">-d</span> <span class="s1">'{"action":"resetprops"}'</span> <span class="s1">'http://G/v1/buckets/&lt;bucket-name&gt;'</span>
</code></pre></div></div>

<h2 id="erasure-coding">Erasure coding</h2>

<p>AIStore provides data protection that comes in several flavors: <a href="#checksumming">end-to-end checksumming</a>, <a href="#n-way-mirror">n-way mirroring</a>, replication (for <em>small</em> objects), and erasure coding.</p>

<p>Erasure coding, or EC, is a well-known storage technique that protects user data by dividing it into N fragments or slices, computing K redundant (parity) slices, and then storing the resulting (N+K) slices on (N+K) storage servers - one slice per target server.</p>

<p>EC schemas are flexible and user-configurable: users can select the N and the K (above), thus ensuring that user data remains available even if the cluster loses <strong>any</strong> (emphasis on the <strong>any</strong>) of its K servers.</p>

<p>A bucket inherits EC settings from global configuration. But it can be overridden on a per bucket basis.</p>

<ul>
  <li><code class="highlighter-rouge">ec.enabled</code>: bool - enables or disabled data protection the bucket</li>
  <li><code class="highlighter-rouge">ec.data_slices</code>: integer in the range [2, 100], representing the number of fragments the object is broken into</li>
  <li><code class="highlighter-rouge">ec.parity_slices</code>: integer in the range [2, 32], representing the number of redundant fragments to provide protection from failures. The value defines the maximum number of storage targets a cluster can lose but it is still able to restore the original object</li>
  <li><code class="highlighter-rouge">ec.objsize_limit</code>: integer indicating the minimum size of an object that is erasure encoded. Smaller objects are just replicated.</li>
  <li><code class="highlighter-rouge">ec.compression</code>: string that contains rules for LZ4 compression used by EC when it sends its fragments and replicas over network. Value “never” disables compression. Other values enable compression: it can be “always” - use compression for all transfers, or list of compression options, like “ratio=1.5” that means “disable compression automatically when compression ratio drops below 1.5”</li>
</ul>

<p>Choose the number data and parity slices depending on the required level of protection and the cluster configuration. The number of storage targets must be greater than the sum of the number of data and parity slices. If the cluster uses only replication (by setting <code class="highlighter-rouge">objsize_limit</code> to a very high value), the number of storage targets must exceed the number of parity slices.</p>

<p>Global rebalance supports erasure-coded buckets. Besides moving existing objects between targets, it repairs damaged objects and their slices if possible.</p>

<p>Notes:</p>

<ul>
  <li>Every data and parity slice is stored on a separate storage target. To reconstruct a damaged object, AIStore requires at least <code class="highlighter-rouge">ec.data_slices</code> slices in total out of data and parity sets</li>
  <li>Small objects are replicated <code class="highlighter-rouge">ec.parity_slices</code> times to have the same level of data protection that big objects do</li>
  <li>Increasing the number of parity slices improves data protection level, but it may hit performance: doubling the number of slices approximately increases the time to encode the object by a factor of two</li>
</ul>

<p>Example of setting bucket properties:</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl <span class="nt">-i</span> <span class="nt">-X</span> PUT <span class="nt">-H</span> <span class="s1">'Content-Type: application/json'</span> <span class="nt">-d</span> <span class="s1">'{"action":"setprops","value":{"lru":{"lowwm":1,"highwm":100,"atime_cache_max":1,"dont_evict_time":"990m","capacity_upd_time":"90m","enabled":true}, "ec": {"enabled": true, "data": 4, "parity": 2}}}'</span> <span class="s1">'http://G/v1/buckets/&lt;bucket-name&gt;'</span>
</code></pre></div></div>

<p>To change only one EC property(e.g, enable or disable EC for a bucket) without touching other bucket properties, use the single set property API. Example of disabling EC:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl <span class="nt">-i</span> <span class="nt">-X</span> PUT <span class="nt">-H</span> <span class="s1">'Content-Type: application/json'</span> <span class="nt">-d</span> <span class="s1">'{"action":"setprops", "name": "ec.enabled", "value": false}'</span> <span class="s1">'http://G/v1/buckets/&lt;bucket-name&gt;'</span>
</code></pre></div></div>

<p>or using AIS CLI utility:</p>

<p>enable EC for a bucket with custom number of data and parity slices. It should be done using 2 commands: the first one changes the numbers while EC is disabled, and the second one enables EC with new slice count:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ais <span class="nb">set </span>props mybucket ec.data_slices<span class="o">=</span>3 ec.parity_slices<span class="o">=</span>3
<span class="nv">$ </span>ais <span class="nb">set </span>props mybucket ec.enabled<span class="o">=</span><span class="nb">true</span>
</code></pre></div></div>

<p>check that EC properties are applied:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ais <span class="nb">ls </span>props mybucket
Property        Value
<span class="o">========</span>        <span class="o">=====</span>
Provider        ais
Access          GET,PUT,DELETE,HEAD,ColdGET
Checksum        Type: xxhash | Validate: ColdGET
Mirror          Disabled
EC              3:3 <span class="o">(</span>256KiB<span class="o">)</span>
LRU             Disabled
Versioning      Disabled
</code></pre></div></div>

<h3 id="limitations">Limitations</h3>

<p>In version 2.1, once a bucket is configured for EC, it’ll stay erasure coded for its entire lifetime - there is currently no supported way to change this once-applied configuration to a different (N, K) schema, disable EC, and/or remove redundant EC-generated content.</p>

<h2 id="n-way-mirror">N-way mirror</h2>
<p>Yet another supported storage service is n-way mirroring providing for bucket-level data redundancy and data protection. The service makes sure that each object in a given distributed (local or Cloud) bucket has exactly <strong>n</strong> object replicas, where n is an arbitrary user-defined integer greater or equal 1.</p>

<p>In other words, AIS n-way mirroring is intended to withstand loss of disks, not storage nodes (aka AIS targets).</p>

<blockquote>
  <p>For the latter, please consider using #erasure-coding and/or any of the alternative backup/restore mechanisms.</p>
</blockquote>

<p>The service ensures is that for any given object there will be <em>no two replicas</em> sharing the same local disk.</p>

<blockquote>
  <p>Unlike <a href="#erasure-coding">erasure coding</a> that takes care of distributing redundant content across <em>different</em> clustered nodes, local mirror is, as the name implies, local. When a bucket is <a href="/ais/setup/config.sh">configured as a mirror</a>, objects placed into this bucket get locally replicated and the replicas are stored in local filesystems.</p>
</blockquote>

<blockquote>
  <p>As aside, note that AIS storage targets can be deployed to utilize Linux LVMs that provide a variety of RAID/mirror schemas.</p>
</blockquote>

<p>The following example configures buckets a, b, and c to store n = 1, 2, and 3 object replicas, respectively:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-i</span> <span class="nt">-X</span> POST <span class="nt">-H</span> <span class="s1">'Content-Type: application/json'</span> <span class="nt">-d</span> <span class="s1">'{"action": "makencopies", "value":1}'</span> <span class="s1">'http://G/v1/buckets/a'</span>
curl <span class="nt">-i</span> <span class="nt">-X</span> POST <span class="nt">-H</span> <span class="s1">'Content-Type: application/json'</span> <span class="nt">-d</span> <span class="s1">'{"action": "makencopies", "value":2}'</span> <span class="s1">'http://G/v1/buckets/b'</span>
curl <span class="nt">-i</span> <span class="nt">-X</span> POST <span class="nt">-H</span> <span class="s1">'Content-Type: application/json'</span> <span class="nt">-d</span> <span class="s1">'{"action": "makencopies", "value":3}'</span> <span class="s1">'http://G/v1/buckets/c'</span>
</code></pre></div></div>

<p>The operations (above) are in fact <a href="/xaction/README.md">extended actions</a> that run asynchronously. Both Cloud and ais buckets are supported. You can monitor completion of those operations via generic <a href="/xaction/README.md">xaction API</a>.</p>

<p>Subsequently, all PUTs into an n-way configured bucket also generate <strong>n</strong> copies for all newly created objects. Which also goes to say that the (“makencopies”) operation, in addition to creating or destroying replicas of existing objects will also automatically re-enable(if n &gt; 1) or disable (if n == 1) mirroring as far as subsequent PUTs are concerned.</p>

<p>Note again that number of local replicas is defined on a per-bucket basis.</p>

<h3 id="read-load-balancing">Read load balancing</h3>
<p>With respect to n-way mirrors, the usual pros-and-cons consideration boils down to (the amount of) utilized space, on the other hand, versus data protection and load balancing, on the other.</p>

<p>Since object replicas are end-to-end protected by <a href="#checksumming">checksums</a> all of them and any one in particular can be used interchangeably to satisfy a GET request thus providing for multiple possible choices of local filesystems and, ultimately, local drives. Given n &gt; 1, AIS will utilize the least loaded drive(s).</p>

<h3 id="more-examples">More examples</h3>
<p>The following sequence creates a bucket named <code class="highlighter-rouge">abc</code>, PUTs an object into it and then converts it into a 3-way mirror:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl <span class="nt">-i</span> <span class="nt">-X</span> POST <span class="nt">-H</span> <span class="s1">'Content-Type: application/json'</span> <span class="nt">-d</span> <span class="s1">'{"action": "createlb"}'</span> <span class="s1">'http://G/v1/buckets/abc'</span>
<span class="nv">$ </span>curl <span class="nt">-L</span> <span class="nt">-X</span> PUT <span class="s1">'http://G/v1/objects/abc/obj1'</span> <span class="nt">-T</span> /tmp/obj1
<span class="nv">$ </span>curl <span class="nt">-i</span> <span class="nt">-X</span> POST <span class="nt">-H</span> <span class="s1">'Content-Type: application/json'</span> <span class="nt">-d</span> <span class="s1">'{"action": "makencopies", "value":3}'</span> <span class="s1">'http://G/v1/buckets/abc'</span>
</code></pre></div></div>

<p>The next command will redefine the <code class="highlighter-rouge">abc</code> bucket created in the previous example as a 2-way mirror - all objects that were previously stored in three replicas will now have only two (replicas):</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>curl <span class="nt">-i</span> <span class="nt">-X</span> POST <span class="nt">-H</span> <span class="s1">'Content-Type: application/json'</span> <span class="nt">-d</span> <span class="s1">'{"action": "makencopies", "value":2}'</span> <span class="s1">'http://G/v1/buckets/abc'</span>
</code></pre></div></div>

  </div><a class="u-url" href="/aistore/docs/storage_svcs" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/aistore/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">AIStore - distributed object storage</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">AIStore - distributed object storage</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>AIStore is a lightweight object storage system with the capability to linearly scale-out with each added storage node and a special focus on petascale deep learning. See more at: github.com/NVIDIA/aistore
</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
